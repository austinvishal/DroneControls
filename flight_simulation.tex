\documentclass[letterpaper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[letterpaper, margin=0.75in]{geometry}
% top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{fancyvrb, newverbs, color}

\lstset { %
    language=C++,
    basicstyle=\footnotesize,% basic font setting
    keywordstyle=\color{blue}\ttfamily,
    stringstyle=\color{red}\ttfamily,
    commentstyle=\color{green}\ttfamily,
    morecomment=[l][\color{magenta}]{\#}
}

\title{Control of a 3D Quadrotor}
\author{Vishal Ramadoss }


\begin{document}
\maketitle

\section{Introduction}

To control the drone in three dimensions, the following controller architecture is adopted. A total of five controllers are implemented.

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{./fig/ControlArchitecture.png}
\caption{\label{fig:controller} Block Diagram (c)Udacity.}
\end{figure}


\subsection{Body rate control} \label{control:bodyrate}

Body rate controller is implemented as a P (proportional) controller. Commanded roll, pitch, and yaw rates ($p, q, r$), are translated into the desired commanded moments along the axis. 

The control equations have the following form:
$$ \dot{\omega}_{p} = k_{p}^{P} (p_c - p) $$
$$ \dot{\omega}_{q} = k_{p}^{Q} (q_c - q) $$
$$ \dot{\omega}_{r} = k_{p}^{R} (r_c - r) $$

The commanded moments M is the product of moment of inertia ($I$, [$kg \cdot m^2$]) and angular acceleration ($\dot{\omega}$, [$radians/s^2$]).
$$ M = I \dot{\omega} $$
The implemented body rate controller is:

\begin{lstlisting}[frame=single]
    V3F momentCmd;
    V3F error_rate = pqrCmd - pqr;
    V3F omega_dot_desired = error_rate * kpPQR;
    momentCmd = omega_dot_desired * V3F(Ixx, Iyy, Izz);
\end{lstlisting}

\subsection{Roll pitch control} \label{control:rollpitch}
The roll-pitch controller a P controller responsible for commanding the roll and pitch rates in the body frame. It uses the lateral acceleration and thrust commands, in addition to the vehicle attitude to output a body rate command. 

The controller first calculates the acceleration in the thrust direction in the body frame $colldes$ from dividing the collective thrust by drone's mass. Then the target angles are calculated from local accelerations. Note both target angles need to be constraint within maximum title angle. Negative sign in NED coordinate system.
\begin{gather*}
R_{13c} = b^x_c = - \ddot{x} / colldes \\
R_{23c} = b^y_c = - \ddot{y} / colldes
\end{gather*}

The desired body rates are then set using a P controller,
$$\dot{b}^x_c  = k_p^{bank}(b^x_c - b^x)$$
$$\dot{b}^y_c  = k_p^{bank}(b^y_c - b^y)$$
where $b^x = R_{13}$ and $b^y = R_{23}$. The given values can be converted into the angular velocities in the body frame by the matrix multiplication. 

$$
\begin{pmatrix} p_c \\ q_c \\ \end{pmatrix}  = \frac{1}{R_{33}}\begin{pmatrix} R_{21} & -R_{11} \\ R_{22} & -R_{12} \end{pmatrix} \begin{pmatrix} \dot{b}^x_c \\ \dot{b}^y_c  \end{pmatrix} 
$$

\begin{lstlisting}[frame=single]
    V3F pqrCmd;
    Mat3x3F R = attitude.RotationMatrix_IwrtB();
    
   float coll_des = collThrustCmd / mass;
   
   if (collThrustCmd > 0.0) {
   float bx_cmd = CONSTRAIN(-accelCmd.x / coll_des, -maxTiltAngle, maxTiltAngle);
   float bx_error = bx_cmd - R(0, 2);
   float bx_dot_cmd = kpBank * bx_error;
   
   float by_cmd = CONSTRAIN(-accelCmd.y / coll_des, -maxTiltAngle, maxTiltAngle);
   float by_error = by_cmd - R(1, 2);
   float by_dot_cmd = kpBank * by_error;
   
   pqrCmd.x = (R(1, 0) * bx_dot_cmd - R(0, 0) * by_dot_cmd) / R(2, 2);
   pqrCmd.y = (R(1, 1) * bx_dot_cmd - R(0, 1) * by_dot_cmd) / R(2, 2);
   
   }
   else {
   // command no rate
   pqrCmd.x = 0.0;
   pqrCmd.y = 0.0;
   }
   pqrCmd.z = 0.0;
\end{lstlisting}

\subsection{Altitude controller} \label{control:altitude}

In this altitude controller implementation, velocity uses a feed forward P controller, 
$$\dot{z} = \dot{z}_c  + k_{p}^{posZ}(z_{c} - z) $$
constrained between maximum ascent rate and maximum descent rate.

Acceleration uses a feed forward PI controller, for non-ideal case 4
$$\ddot{z} = \ddot{z}_c + k_{p}^{velZ}(\dot{z}_{c} - \dot{z}) + k_i^{posZ}\int_0^t(z_{c} - z)dt'$$ 

In the altitude controller, the thrust is controlled through the vertical acceleration. 
$$ m \ddot{z} = - F_{thrust} b^z + m g$$
$g$ is in positive direction, thrust is in negative direction in the NED system. $b^z = R_{33}$ are the the last row last column element in the rotation matrix to transform back from inertial frame.
$$ F_{thrust} = m (g - \ddot{z})/b^z$$ 

The C++ implementation code:
\begin{lstlisting}[frame=single]
    float z_error = posZCmd - posZ;
    float velocityZ = kpPosZ * z_error + velZCmd;
    float b_z = R(2, 2);
    // Limit the ascent/descent rate
    velocityZ = CONSTRAIN(velocityZ, -maxAscentRate, maxDescentRate);
    
    integratedAltitudeError += z_error * dt;
    
    float accelerZ = accelZCmd
    + kpVelZ * (velocityZ - velZ)
    + KiPosZ * integratedAltitudeError;
    
    thrust = mass * (CONST_GRAVITY - accelerZ) / b_z;

\end{lstlisting}

\subsection{Lateral position control} \label{control:lateral}
The lateral position control uses two cascaded feedforward linear P controller.

$$\dot{x} = \dot{x}_c  + k_{p}^{PosXY}(x_{c} - x), \:
  \dot{y} = \dot{y}_c  + k_{p}^{PosXY}(y_{c} - y)$$
$$\ddot{x} = \ddot{x}_c  + k_{p}^{VelXY}(\dot{x_{c}} - \dot{x}), \:
  \ddot{y} = \ddot{y}_c  + k_{p}^{VelXY}(\dot{x_{c}} - \dot{y})$$


\begin{lstlisting}[frame=single]
   V3F velo_xy = velCmd + kpPosXY * (posCmd - pos);
   accelCmd = accelCmd + kpVelXY * (velo_xy - vel);
    
\end{lstlisting}

\subsection{Yaw control} \label{control:yaw}
 It is a linear proportional heading controller to command yaw rate. Since heading angle has to be between 0 and $2\pi$, fmodf() function is used to constraint the input heading angle and normalized.

$$ r_c = k_p^{yaw} (\psi_c - \psi) $$

\begin{lstlisting}[frame=single]
    yawCmd = fmodf(yawCmd, M_PI * 2.0);
    float yaw_error = AngleNormF(yawCmd - yaw);
    yawRateCmd = kpYaw * yaw_error;
\end{lstlisting}

\subsection{Calculate the motor commands } \label{control:motorcommand}

Distance from vehicle origin to motors is $L$, the distance from motor to x or y axis is $ l = L/\sqrt[]{2}$. The thrust from each propeller is labeled as $F_1$, $F_2$, $F_3$, $F_4$, the collective thrust is
$$ F_{total} = F_1 + F_2 + F_3 + F_4 $$
For roll motion, the moments generated by the $1^{st}$ and $3^{rd}$ propellers are counteracted by the moment generated by the $2^{nd}$ and the $4^{th}$ propellers. 
$$ \tau_x = (F_1 - F_2 + F_3 - F_4)l $$
In the same fashion, the pitch is generated by the mismatch of the moments created by $1^{st}$ and $2^{nd}$ propellers and the moment generated by the $3^{rd}$ and $4^{th}$ propellers.
$$ \tau_y = (F_1 + F_2 - F_3 - F_4)l $$
Contrary to the roll and pitch, the yaw motion is executed by the mismatch of the moments generated by the propellers along the z axis by the reactive force. The moment generated by the propeller is directed opposite of its rotation and is proportional to the square of the angular velocities. The propellers 1 and 4 rotate in clockwise thus producing the moment in the counterclockwise direction with negative moments. Propellers 2 and 3 rotate in counterclockwise thus the resulting moments are in opposite and have the positive moments.
\begin{align*}
\tau_z = -k_{appa}  (F_1 - F_2 - F_3 + F_4)
\end{align*}

 Solve  4 equations for thrust from each propeller,
\begin{align*}
F_1 = (F_{total} + \tau_x / l + \tau_y / l  -\tau_z / k_{appa})/4  \\
F_2 = (F_{total} - \tau_x / l + \tau_y / l  +\tau_z / k_{appa})/4 \\
F_3 = (F_{total} + \tau_x / l - \tau_y / l  +\tau_z / k_{appa})/4 \\
F_4 = (F_{total} - \tau_x / l - \tau_y / l  -\tau_z / k_{appa})/4
\end{align*}

Motor command implementation in C++:
\begin{lstlisting}[frame=single]
    float lenth = L / sqrtf(2);
    float F_x     = momentCmd.x / lenth;
    float F_y     = momentCmd.y / lenth;
    float F_z     = - momentCmd.z / kappa;
    float F_total = collThrustCmd;
    cmd.desiredThrustsN[0] = (F_total + F_x + F_y + F_z) / 4.f; // front left, [N]
    cmd.desiredThrustsN[1] = (F_total - F_x + F_y - F_z) / 4.f; // front right
    cmd.desiredThrustsN[2] = (F_total + F_x - F_y - F_z) / 4.f; // rear left
    cmd.desiredThrustsN[3] = (F_total - F_x - F_y + F_z) / 4.f; // rear right
\end{lstlisting}

\section{Flight Control Gain Tuning}

Tuning these control gain parameters in QuadControlParams.txt.

\subsection{S1: Intro}

To make drone not falling to the ground, drone's gravity need to be compensated from propeller's thrust force. All we have to do is to adjust the Mass control parameter to $0.5$ in QuadControlParams.txt. Scenario 1 is shown in Figure~\ref{fig:scenario1}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/scenario1.png}
\caption{\label{fig:scenario1} S1 Tuning Mass.}
\end{figure}

\subsection{S2: Body rate and roll/pitch control}


\begin{description}

\item [GenerateMotorCommands()] The motor command implementation can be found in subsection~\ref{control:motorcommand}. No gain tuning for this function.

\item [BodyRateControl()] The body rate control implementation can be found in subsection~\ref{control:bodyrate}. Tuning kpPQR helps to get the vehicle to stop spinning quickly once the  roll (omega.x) gets to zero. The default kpPQR gains works
\begin{Verbatim}[frame=single]
# Angle rate gains
kpPQR = 23, 23, 5
\end{Verbatim} 

\item [RollPitchControl()] The roll pitch control implementation can be found in subsection~\ref{control:rollpitch}. Tune kpBank minimize settling time and avoid too much overshoot. 
\begin{Verbatim}[frame=single,commandchars=\\\{\}]
# Angle control gains
kpBank = \textcolor{red}{8}
\end{Verbatim} 

\end{description}



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/scenario2.png}
\caption{\label{fig:scenario2} Scenario 2 Body rate and roll/pitch control.}
\end{figure}

\subsection{S3: Position/velocity and yaw angle control}


\begin{description}
\item [LateralPositionControl()] The code for lateral position  control is implemented in~\ref{control:altitude}. 

\item [AltitudeControl()] The code for altitude control is implemented in~\ref{control:lateral}. 

Tuning parameters kpPosZ, kpVelZ, kpVelXY and kpVelXY find out only kpPosXY need to be changed from 1 to 2 to make the quads go to their destination points and tracking error go down. 

\begin{Verbatim}[frame=single,commandchars=\\\{\}]
# Position control gains
kpPosZ = 1
kpPosXY = \textcolor{red}{2}
# Velocity control gains
kpVelXY = 4
kpVelZ = 4
\end{Verbatim} 

 one quad remains rotated in yaw. 

\item [YawControl()] The code for yaw control is implemented in~\ref{control:yaw}. Tuning parameters kpYaw to 2 makes it work.
 

\begin{Verbatim}[frame=single,commandchars=\\\{\}]
# Angle control gains
kpYaw = \textcolor{red}{2}
\end{Verbatim} 

\end{description}



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/scenario3.png}
\caption{\label{fig:scenario3} Scenario 3 Position/velocity and yaw angle control.}
\end{figure}

\subsection{S4: Non-idealities and robustness}

Scenario 4 simulation explores the non-ideality and robustness of controllers. Three quads are configured to move and have different characteristics:

\begin{itemize}
\item The green quad with shifted COM
\item The orange vehicle is ideal case
\item The red vehicle is heavier 
\end{itemize}

With controller gain parameters set from the previuos step, not all the quads  moving along to the target. Adding integral control in AltitudeControl() helps with the different-mass vehicle. see Figure~\ref{fig:scenario4}.

\begin{Verbatim}[frame=single, commandchars=\\\{\}]
# Position control gains
kpPosXY = \textcolor{red}{3}
kpPosZ = \textcolor{red}{5}
KiPosZ = \textcolor{red}{10}

# Velocity control gains
kpVelXY = \textcolor{red}{10}
kpVelZ = \textcolor{red}{16}

# Angle control gains
kpBank = \textcolor{red}{10}
kpYaw = \textcolor{red}{2}

# Angle rate gains
kpPQR = \textcolor{red}{61}, \textcolor{red}{61}, 5
\end{Verbatim}



\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/scenario4.png}
\caption{\label{fig:scenario4} Scenario 4 Non-idealities and robustness.}
\end{figure}

\subsection{S5: Tracking trajectories}

Scenario 5 put all working parts of a controller together and test its performance on a yet another complex trajectory. Without any further gain tuning from previous scenario,it works, shown in Figure~\ref{fig:scenario5}.


\begin{figure}[ht]
\centering
\includegraphics[width=0.8\textwidth]{./fig/scenario5.png}
\caption{\label{fig:scenario5} Scenario 5 Tracking trajectories.}
\end{figure}
\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\textwidth]{./fig/scenario_test1.png}
	\caption{\label{fig:scenario_test1} Bonus Scenario: Test many quards.}
\end{figure}
\subsection{Bonus Scenario}

Now the C++ controller is able to fly the all provided test trajectories and also bonus case.  (Figure~\ref{fig:scenario_test1}). 



\section*{Acknowledgements}

To Udacity team for this project and for the links provided

$
https://docs.px4.io/v1.9.0/en/config_mc/pidtuningguidemulticopter.html $

$https://github.com/darienmt/$

$
http://www.dynsyslab.org/wp-content/papercite-data/pdf/schoellig-acc12.pdf
$
\end{document}